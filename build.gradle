// ======================
// CARPET MOD BUILDSCRIPT
// ======================


// ===== HEADER =====

// Use the ForgeGradle plugin (must go absolutely first! (before imports!) :( )
buildscript
{
	repositories
	{
		mavenCentral()
		maven {url 'http://files.minecraftforge.net/maven'}
		maven {url 'http://plugins.gradle.org/m2/'}
	}
	dependencies
	{
		classpath 'net.minecraftforge.gradle:ForgeGradle:2.3-SNAPSHOT'
		classpath 'de.undercouch:gradle-download-task:3.4.3'
		classpath 'commons-io:commons-io:2.6'
		classpath "gradle.plugin.com.dorongold.plugins:task-tree:1.3"
	}
}
apply plugin: 'java'
apply plugin: 'maven'
def patcher_plugin = plugins.apply 'net.minecraftforge.gradle.patcher'
apply plugin: 'de.undercouch.download'
apply plugin: "com.dorongold.task-tree"


import com.google.common.io.Resources
import de.undercouch.gradle.tasks.download.Download
import groovy.io.FileType
import java.text.SimpleDateFormat
import java.util.zip.ZipFile
import net.minecraftforge.gradle.common.Constants
import net.minecraftforge.gradle.patcher.PatcherConstants
import net.minecraftforge.gradle.patcher.TaskReobfuscate
import net.minecraftforge.gradle.patcher.TaskSubprojectCall
import net.minecraftforge.gradle.util.json.version.OS
import org.apache.commons.io.IOUtils


// ===== PROPERTIES =====

// Set basic project properties
group = 'carpet'
version = new SimpleDateFormat('yy_MM_dd').format(new Date())

allprojects {
	sourceSets.main.java.srcDirs = ['src']
}

// ForgeGradle settings
minecraft
{
	version = '1.12'
	mappings = 'snapshot_20161116' // Same as MCP 4.10
	workspaceDir = 'projects'
	// versionJson is used to download assets because ForgeGradle insists
	versionJson = "jsons/${minecraft.version}-dev.json"
	
	def common = {
		patchPrefixOriginal = '../src-base/minecraft'
		patchPrefixChanged = '../src-work/minecraft'
		mainClassServer = 'net.minecraft.server.MinecraftServer'
	}
	
	projects
	{
		carpet
		{
			rootDir '.'
			sourcesDir 'carpetSrc'
			patchDir 'patches'
			patchAfter 'clean'
			genPatchesFrom 'clean'
			genMcpPatches = false
			applyMcpPatches = false
			s2sKeepImports = true
			with common
		}
	}
}
processJson
{
	// also used to download assets
	releaseJson = 'jsons/${minecraft.version}-rel.json'
}


// ===== TOP-LEVEL TASKS =====

// There must be no new line before braces for tasks or compile errors happen :,(

/**
 * setupCarpet is used after you pull from the remote repository
 * 1. git pull ...
 * 2. gradlew setupCarpet
 */
task setupCarpet {
	dependsOn 'setup'
}


// ===== MODIFY EXISTING TASKS =====

// Exclude Forge files
extractCarpetSources
{
	exclude '**/SideOnly.java', '**/Side.java'
}
extractCarpetResources
{
	exclude "**/log4j2.xml"
}


// ===== DECOMPILING AND DEOBFUSCATING =====

// Make the client the server
mergeJars.dependsOn.remove downloadClient
mergeJars.client = {mergeJars.server}
sourceProcessJar.patches = patcher_plugin.delayedFile(Constants.MCP_PATCHES_SERVER)

// Make decompilation as close as possible to the original MCP
remapCleanJar.addsJavadocs = true
remapCarpetJar.addsJavadocs = true

task(downloadMcp, type: Download) {
	src 'http://www.modcoderpack.com/files/mcp940.zip'
	dest 'build/localCache/downloadMcp/mcp940.zip'
}
task(extractAstyle, type: Copy) {
	from(zipTree('build/localCache/downloadMcp/mcp940.zip'))
	{
		include 'runtime/bin/astyle.exe'
		include 'runtime/bin/astyle-osx'
	}
	into 'build/localCache/mcp'
	dependsOn downloadMcp
}
sourceProcessJar.outJar = 'build/localCache/sourceProcessJar/sourceProcessed.jar'
task(extractSrcForAstyle, type: Copy) {
	from zipTree('build/localCache/sourceProcessJar/sourceProcessed.jar')
	into 'build/localCache/astyle'
	dependsOn sourceProcessJar
}
task(runAstyle, type: Exec) {
	def extra_args = ['--suffix=none', '--quiet', '--recursive',
			'--options=' + patcher_plugin.delayedFile(Constants.MCP_DATA_STYLE), 'build/localCache/astyle/*.java']
	switch (OS.CURRENT)
	{
		case OS.WINDOWS:
			commandLine(['"build/localCache/mcp/runtime/bin/astyle.exe"'] + extra_args)
			break
		case OS.OSX:
			commandLine(['build/localCache/mcp/runtime/bin/astyle-osx'] + extra_args)
			break
		default:
			commandLine(['astyle'] + extra_args)
			break
	}
	
	dependsOn extractSrcForAstyle
	if (OS.CURRENT == OS.WINDOWS || OS.CURRENT == OS.OSX)
		dependsOn extractAstyle
}
task(zipAstyledSrc, type: Zip) {
	from('build/localCache/astyle')
	exclude '**/*.orig'
	
	def destFile = file(patcher_plugin.delayedFile(PatcherConstants.JAR_DECOMP_POST))
	destinationDir = destFile.getParentFile()
	archiveName = destFile.getName()
	includeEmptyDirs = false
	
	dependsOn runAstyle
}
remapCleanJar.dependsOn zipAstyledSrc
patchCarpetJar.dependsOn zipAstyledSrc
remapCarpetJar.dependsOn zipAstyledSrc


// ===== RECOMPILING AND REOBFUSCATING =====

// Create recompile clean tasks so that we can properly check that two class files are equal without relying on using the same compiler as Mojang

// Compile
task(compileClean, type: TaskSubprojectCall)
{
	projectDir = patcher_plugin.subWorkspace('Clean')
	callLine = 'jar'
	addInitScript(Resources.getResource(TaskSubprojectCall, 'initscriptJar.gradle'))
	addReplacement('@RECOMP_DIR@', 'build/compileClean')
	addReplacement('@JAR_NAME@', 'recompiled.jar')
	mustRunAfter setup
}
// Obfuscate
task(reobfClean, type: TaskReobfuscate)
{
	srg = reobfuscate.srg
	exc = reobfuscate.exc
	preFFJar = reobfuscate.preFFJar
	inJar = file('projects/Clean/build/compileClean/recompiled.jar')
	methodsCsv = reobfuscate.methodsCsv
	fieldsCsv = reobfuscate.fieldsCsv
	outJar = file('build/localCache/reobfClean/reobfuscated.jar')
	addLibs configurations.forgeGradleMcDeps
	dependsOn compileClean, genSrgs, setup
}

// Do the output Jar ourselves because the build-in ForgeGradle version assumes we have permission
// to redistribute the MCP mappings (we don't)
task(carpetOutputJar, type: Zip)
{
	from(zipTree(patcher_plugin.delayedFile(PatcherConstants.JAR_OBFUSCATED)))
	{
		eachFile
		{ moddedFile ->
			def entryName = moddedFile.getRelativePath().toString()
			if (!entryName.contains('/') || entryName.startsWith('net/minecraft/')) // i.e. was this file in vanilla?
			{
				if (!entryName.endsWith('.class'))
				{
					moddedFile.exclude()
				}
				else
				{
					def vanillaJar = new ZipFile(file('build/localCache/reobfClean/reobfuscated.jar'))
					def vanillaEntry = vanillaJar.getEntry entryName
					if (vanillaEntry == null)
					{
						moddedFile.exclude()
					}
					else
					{
						def moddedJar = new ZipFile(file(patcher_plugin.delayedFile(PatcherConstants.JAR_OBFUSCATED)))
						def moddedEntry = moddedJar.getEntry entryName
						if (IOUtils.contentEquals(vanillaJar.getInputStream(vanillaEntry), moddedJar.getInputStream(moddedEntry)))
							moddedFile.exclude()
					}
				}
			}
		}
	}
	
	archiveName = "Carpet_v${project.version}.zip"
	destinationDir = outputJar.destinationDir
	includeEmptyDirs = false
	
	dependsOn reobfClean
}
// Make carpetOutputJar replace outputJar
tasks.each
{ t ->
	if (t.dependsOn.contains(outputJar))
	{
		t.dependsOn.remove outputJar
		t.dependsOn carpetOutputJar
	}
}
outputJar.destinationDir = file('build/localCache/outputTrash')


// ===== MAKE ALL SOURCES IN SAME DIRECTORY =====

task(copyCarpetFromSrc, type: Copy) {
	from('src/')
	{
		eachFile
		{ file ->
			if (new File('projects/Clean/src/main/java', file.getRelativePath().toString()).isFile())
				file.exclude()
		}
	}
	into 'carpetSrc/'
	includeEmptyDirs = false
	dependsOn extractCleanSources
}
task(copyMcFromSrc, type: Copy) {
	from('src/')
	{
		eachFile
		{ file ->
			if (!(new File('projects/Clean/src/main/java', file.getRelativePath().toString()).isFile()))
				file.exclude()
		}
	}
	into 'projects/Carpet/src/main/java'
	includeEmptyDirs = false
	dependsOn extractCleanSources
}
task(copyCarpetToSrc, type: Copy) {
	from 'carpetSrc/'
	into 'src/'
}
task(copyMcToSrc, type: Copy) {
	from 'projects/Carpet/src/main/java'
	into 'src/'
	dependsOn extractCarpetSources
}

makeJarCarpet.dependsOn copyCarpetFromSrc, copyMcFromSrc
genIdeProjects.dependsOn copyCarpetToSrc, copyMcToSrc

// Use code injection to add carpetSrc/ to the source dirs
String injected = """${PatcherConstants.JAR_PROJECT_RECOMPILED.substring(PatcherConstants.DIR_PROJECT_CACHE.length() + 1)}";
println '====='
sourceSets.main.java.srcDirs.each {println it}
def hacky_empty_str = "
"""
injected = injected.substring(0, injected.length() - 1)
makeJarCarpet.addReplacement('@JAR_NAME@', injected)

clean {
	delete 'src'
}


// ===== REMOVE UNNECESSARY TASKS =====

tasks.each
{ t ->
	t.dependsOn.remove makeCleanStart
	t.dependsOn.remove makeCarpetStart
	t.dependsOn.remove makeEclipseCleanRunClient
	t.dependsOn.remove makeEclipseCarpetRunClient
	t.dependsOn.remove makeIdeaCleanRunClient
	t.dependsOn.remove makeIdeaCarpetRunClient
}
installer.enabled = false
installer.dependsOn.remove downloadInstaller
installer.dependsOn.remove outputJar
installer.dependsOn.remove processJson
