// ======================
// JAR MOD BUILDSCRIPT
// ======================


// ===== HEADER =====

// Use the ForgeGradle plugin (must go absolutely first! (before imports!) :( )
buildscript
{
	repositories
	{
		mavenCentral()
		maven {url 'http://files.minecraftforge.net/maven'}
		maven {url 'http://plugins.gradle.org/m2/'}
	}
	dependencies
	{
		classpath 'net.minecraftforge.gradle:ForgeGradle:2.3-SNAPSHOT'
		classpath 'de.undercouch:gradle-download-task:3.4.3'
		classpath 'commons-io:commons-io:2.6'
		classpath "gradle.plugin.com.dorongold.plugins:task-tree:1.3" // For debug purposes
	}
}
apply plugin: 'java'
apply plugin: 'maven'
def patcher_plugin = plugins.apply 'net.minecraftforge.gradle.patcher'
apply plugin: 'de.undercouch.download'
apply plugin: "com.dorongold.task-tree" // For debug purposes


import com.google.common.io.Resources
import de.undercouch.gradle.tasks.download.Download
import groovy.io.FileType
import java.text.SimpleDateFormat
import java.util.zip.ZipFile
import net.minecraftforge.fml.relauncher.Side
import net.minecraftforge.gradle.common.Constants
import net.minecraftforge.gradle.patcher.PatcherConstants
import net.minecraftforge.gradle.patcher.TaskReobfuscate
import net.minecraftforge.gradle.patcher.TaskSubprojectCall
import net.minecraftforge.gradle.util.json.version.OS
import org.apache.commons.io.IOUtils


// ===== PROPERTIES =====

// Set basic project properties
group = name
version = new SimpleDateFormat('yy_MM_dd').format(new Date())
def capitalizedName = '' + Character.toUpperCase(project.name.charAt(0)) + project.name.substring(1)

allprojects {
	sourceSets.main.java.srcDirs = ['src']
}

// ForgeGradle settings
minecraft
{
	version = '1.12'
	mappings = 'snapshot_20161116' // Same as MCP 4.10
	workspaceDir = 'projects'
	// versionJson is used to download assets because ForgeGradle insists
	versionJson = "jsons/${minecraft.version}-dev.json"
	
	def common = {
		patchPrefixOriginal = '../src-base/minecraft'
		patchPrefixChanged = '../src-work/minecraft'
		mainClassServer = 'net.minecraft.server.MinecraftServer'
	}
	
	project(project.name)
	{
		rootDir '.'
		sourcesDir project.name + 'Src'
		patchDir 'patches'
		patchAfter 'clean'
		genPatchesFrom 'clean'
		genMcpPatches = false
		applyMcpPatches = false
		s2sKeepImports = true
		with common
	}
}
processJson
{
	// also used to download assets
	releaseJson = "jsons/${minecraft.version}-rel.json"
}


// ===== TOP-LEVEL TASKS =====

// There must be no new line before braces for tasks or compile errors happen :,(

/**
 * setup[Project] is used after you pull from the remote repository
 * 1. git pull ...
 * 2. gradlew setup[Project]
 */
task('setup' + capitalizedName) {
	dependsOn 'setup'
}


// ===== MODIFY EXISTING TASKS =====

// Exclude Forge files
if (gradle.side == 'client' || gradle.side == 'server')
	tasks.getByName('extract' + capitalizedName + 'Sources').exclude 'net/minecraftforge/fml/relauncher/SideOnly.java', 'net/minecraftforge/fml/relauncher/Side.java'
tasks.getByName('extract' + capitalizedName + 'Resources').exclude "**/log4j2.xml"


// ===== DECOMPILING AND DEOBFUSCATING =====

// Only decompile the right side
if (gradle.side == 'client')
{
	deobfuscateJar.dependsOn.remove mergeJars
	deobfuscateJar.dependsOn downloadClient
	sourceProcessJar.patches = patcher_plugin.delayedFile(Constants.MCP_PATCHES_CLIENT)
	deobfuscateJar.inJar = patcher_plugin.delayedFile(Constants.JAR_CLIENT_FRESH)
}
else if (gradle.side == 'server')
{
	// TODO: ffs half these lines don't work, fix later
	deobfuscateJar.dependsOn.remove mergeJars
	deobfuscateJar.dependsOn splitServerJar
	sourceProcessJar.patches = patcher_plugin.delayedFile(Constants.MCP_PATCHES_SERVER)
	deobfuscateJar.inJar = patcher_plugin.delayedFile(Constants.JAR_SERVER_PURE)
}

// Make decompilation as close as possible to the original MCP
if (gradle.useJavadocs)
{
	remapCleanJar.addsJavadocs = true
	tasks.getByName('remap' + capitalizedName + 'Jar').addsJavadocs = true
}

if (gradle.useAstyle)
{
	task(downloadMcp, type: Download) {
		src 'http://www.modcoderpack.com/files/mcp940.zip'
		dest 'build/localCache/downloadMcp/mcp940.zip'
	}
	task(extractAstyle, type: Copy) {
		from(zipTree('build/localCache/downloadMcp/mcp940.zip'))
		{
			include 'runtime/bin/astyle.exe'
			include 'runtime/bin/astyle-osx'
		}
		into 'build/localCache/mcp'
		dependsOn downloadMcp
	}
	sourceProcessJar.outJar = 'build/localCache/sourceProcessJar/sourceProcessed.jar'
	task(extractSrcForAstyle, type: Copy) {
		from zipTree('build/localCache/sourceProcessJar/sourceProcessed.jar')
		into 'build/localCache/astyle'
		dependsOn sourceProcessJar
	}
	task(runAstyle, type: Exec) {
		def extra_args = ['--suffix=none', '--quiet', '--recursive',
				'--options=' + patcher_plugin.delayedFile(Constants.MCP_DATA_STYLE), 'build/localCache/astyle/*.java']
		switch (OS.CURRENT)
		{
			case OS.WINDOWS:
				commandLine(['"build/localCache/mcp/runtime/bin/astyle.exe"'] + extra_args)
				break
			case OS.OSX:
				commandLine(['build/localCache/mcp/runtime/bin/astyle-osx'] + extra_args)
				break
			default:
				commandLine(['astyle'] + extra_args)
				break
		}
		
		dependsOn extractSrcForAstyle
		if (OS.CURRENT == OS.WINDOWS || OS.CURRENT == OS.OSX)
			dependsOn extractAstyle
	}
	task(zipAstyledSrc, type: Zip) {
		from('build/localCache/astyle')
		exclude '**/*.orig'
		
		def destFile = file(patcher_plugin.delayedFile(PatcherConstants.JAR_DECOMP_POST))
		destinationDir = destFile.getParentFile()
		archiveName = destFile.getName()
		includeEmptyDirs = false
		
		dependsOn runAstyle
	}
	remapCleanJar.dependsOn zipAstyledSrc
	tasks.getByName('patch' + capitalizedName + 'Jar').dependsOn zipAstyledSrc
	tasks.getByName('remap' + capitalizedName + 'Jar').dependsOn zipAstyledSrc
}


// ===== RECOMPILING AND REOBFUSCATING =====

// Create recompile clean tasks so that we can properly check that two class files are equal without relying on using the same compiler as Mojang

// Compile
task(compileClean, type: TaskSubprojectCall)
{
	projectDir = patcher_plugin.subWorkspace('Clean')
	callLine = 'jar'
	addInitScript(Resources.getResource(TaskSubprojectCall, 'initscriptJar.gradle'))
	addReplacement('@RECOMP_DIR@', 'build/compileClean')
	addReplacement('@JAR_NAME@', 'recompiled.jar')
	mustRunAfter setup
}
// Obfuscate
task(reobfClean, type: TaskReobfuscate)
{
	srg = reobfuscate.srg
	exc = reobfuscate.exc
	preFFJar = reobfuscate.preFFJar
	inJar = file('projects/Clean/build/compileClean/recompiled.jar')
	methodsCsv = reobfuscate.methodsCsv
	fieldsCsv = reobfuscate.fieldsCsv
	outJar = file('build/localCache/reobfClean/reobfuscated.jar')
	addLibs configurations.forgeGradleMcDeps
	dependsOn compileClean, genSrgs, setup
}

// Do the output Jar ourselves because the build-in ForgeGradle version assumes we have permission
// to redistribute the MCP mappings (we don't)
// Also, we do this for each side when both sides are enabled, filtering out using SideOnly
void configureOutputJar(def patcher_plugin, def capitalizedName, Zip task, Side side)
{
	task.from(zipTree(patcher_plugin.delayedFile(PatcherConstants.JAR_OBFUSCATED)))
	{
		eachFile
		{ moddedFile ->
			def entryName = moddedFile.getRelativePath().toString()
			def moddedJar = new ZipFile(file(patcher_plugin.delayedFile(PatcherConstants.JAR_OBFUSCATED)))
			def moddedEntry = moddedJar.getEntry entryName
			if (!entryName.contains('/') || entryName.startsWith('net/minecraft/')) // i.e. was this file in vanilla?
			{
				if (!entryName.endsWith('.class'))
				{
					moddedFile.exclude()
				}
				else
				{
					def vanillaJar = new ZipFile(file('build/localCache/reobfClean/reobfuscated.jar'))
					def vanillaEntry = vanillaJar.getEntry entryName
					if (vanillaEntry == null)
					{
						moddedFile.exclude()
					}
					else
					{
						if (IOUtils.contentEquals(vanillaJar.getInputStream(vanillaEntry), moddedJar.getInputStream(moddedEntry)))
							moddedFile.exclude()
					}
				}
			}
			if (entryName.endsWith('.class'))
				if (side != null)
					if (!SideFilter.matchesSide(moddedJar.getInputStream(moddedEntry), side))
						moddedFile.exclude()
		}
	}
	
	task.exclude 'net/minecraftforge/fml/relauncher/Side.class', 'net/minecraftforge/fml/relauncher/SideOnly.class'
	
	if (side != null)
	{
		task.filter([side: side, fileSupplier: { filename ->
			def entryName = filename + '.class'
			def moddedJar = new ZipFile(file(patcher_plugin.delayedFile(PatcherConstants.JAR_OBFUSCATED)))
			def moddedEntry = moddedJar.getEntry entryName
			return moddedJar.getInputStream(moddedEntry)
		}], SideFilter)
		task.filteringCharset = 'US-ASCII'
	}
	
	if (side == null)
		task.archiveName = "${capitalizedName}_v${project.version}.zip"
	else
		task.archiveName = "${capitalizedName}_v${project.version}_${side.name().toLowerCase(Locale.ENGLISH)}.zip"
	task.destinationDir = outputJar.destinationDir
	task.includeEmptyDirs = false
	
	task.dependsOn reobfClean
}
def outputJarTasks = []
if (gradle.side == 'client' || gradle.side == 'server')
{
	def outputJarTask = task(project.name + 'OutputJar', type: Zip)
	configureOutputJar(patcher_plugin, capitalizedName, outputJarTask, null)
	outputJarTasks += outputJarTask
}
else
{
	def outputJarTask = task(project.name + 'OutputJarClient', type: Zip)
	configureOutputJar(patcher_plugin, capitalizedName, outputJarTask, Side.CLIENT)
	outputJarTasks += outputJarTask
	outputJarTask = task(project.name + 'OutputJarServer', type: Zip)
	configureOutputJar(patcher_plugin, capitalizedName, outputJarTask, Side.SERVER)
	outputJarTasks += outputJarTask
}
// Make [project]OutputJar replace outputJar
tasks.each
{ t ->
	if (t.dependsOn.contains(outputJar))
	{
		t.dependsOn.remove outputJar
		t.dependsOn outputJarTasks
	}
}
outputJar.destinationDir = file('build/localCache/outputTrash')


// ===== MAKE ALL SOURCES IN SAME DIRECTORY =====

task('copy' + capitalizedName + 'FromSrc', type: Copy) {
	from('src/')
	{
		eachFile
		{ file ->
			if (new File('projects/Clean/src/main/java', file.getRelativePath().toString()).isFile())
				file.exclude()
		}
	}
	into project.name + 'Src/'
	includeEmptyDirs = false
	dependsOn extractCleanSources
}
task(copyMcFromSrc, type: Copy) {
	from('src/')
	{
		include 'mcp/**'
	}
	from('src/')
	{
		eachFile
		{ file ->
			if (!(new File('projects/Clean/src/main/java', file.getRelativePath().toString()).isFile()))
				file.exclude()
		}
		exclude 'mcp/**'
		if (gradle.useJavadocs)
			filter StripJavadoc // so the patcher isn't bugged
	}
	into "projects/${capitalizedName}/src/main/java"
	includeEmptyDirs = false
	dependsOn extractCleanSources
}
task('copy' + capitalizedName + 'ToSrc', type: Copy) {
	from project.name + 'Src/'
	into 'src/'
}
task(copyMcToSrc, type: Copy) {
	from "projects/${capitalizedName}/src/main/java"
	into 'src/'
	dependsOn tasks.getByName('extract' + capitalizedName + 'Sources')
}

tasks.getByName('makeJar' + capitalizedName).dependsOn tasks.getByName('copy' + capitalizedName + 'FromSrc'), copyMcFromSrc
genIdeProjects.dependsOn tasks.getByName('copy' + capitalizedName + 'ToSrc'), copyMcToSrc

clean {
	delete 'src'
}


// ===== REMOVE UNNECESSARY TASKS =====

def sideToIgnore = null
if (gradle.side == 'client')
	sideToIgnore = 'Server'
else if (gradle.side == 'server')
	sideToIgnore = 'Client'
tasks.each
{ t ->
	t.dependsOn.remove makeCleanStart
	t.dependsOn.remove tasks.getByName('make' + capitalizedName + 'Start')
	if (sideToIgnore != null)
	{
		t.dependsOn.remove tasks.getByName('makeEclipseCleanRun' + sideToIgnore)
		t.dependsOn.remove tasks.getByName('makeEclipse' + capitalizedName + 'Run' + sideToIgnore)
		t.dependsOn.remove tasks.getByName('makeIdeaCleanRun' + sideToIgnore)
		t.dependsOn.remove tasks.getByName('makeIdea' + capitalizedName + 'Run' + sideToIgnore)
	}
}
installer.enabled = false
installer.dependsOn.remove downloadInstaller
installer.dependsOn.remove outputJar
installer.dependsOn.remove processJson
